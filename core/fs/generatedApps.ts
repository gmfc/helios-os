// This file is generated by tools/build-apps.ts
// Do not edit manually.

export const APT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const action = argv[0];\n  if (!action || action !== \"search\" && action !== \"install\" && action !== \"remove\") {\n    await syscall(\"write\", STDERR_FD, encode(\"usage: apt <search|install|remove> <pkg>\\n\"));\n    return 1;\n  }\n  let indexRaw;\n  try {\n    indexRaw = await readText(syscall, \"/etc/apt/index.json\");\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: index not found\\n\"));\n    return 1;\n  }\n  let index;\n  try {\n    index = JSON.parse(indexRaw);\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: bad index\\n\"));\n    return 1;\n  }\n  if (action === \"search\") {\n    const term = argv[1] || \"\";\n    for (const p of index) {\n      if (p.name.includes(term)) {\n        await syscall(\"write\", STDOUT_FD, encode(p.name + \"\\n\"));\n      }\n    }\n    return 0;\n  }\n  if (action === \"remove\") {\n    const name2 = argv[1];\n    if (!name2) {\n      await syscall(\"write\", STDERR_FD, encode(\"apt remove: missing package name\\n\"));\n      return 1;\n    }\n    let manRaw;\n    try {\n      manRaw = await readText(syscall, `/var/pkg/${name2}.json`);\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"apt: package not installed\\n\"));\n      return 1;\n    }\n    let manifest;\n    try {\n      manifest = JSON.parse(manRaw);\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"apt: bad manifest\\n\"));\n      return 1;\n    }\n    for (const f of manifest.files) {\n      try {\n        await syscall(\"unlink\", f);\n      } catch {\n      }\n    }\n    try {\n      await syscall(\"unlink\", `/var/pkg/${name2}.json`);\n    } catch {\n    }\n    await syscall(\"write\", STDOUT_FD, encode(\"removed \" + name2 + \"\\n\"));\n    return 0;\n  }\n  const name = argv[1];\n  if (!name) {\n    await syscall(\"write\", STDERR_FD, encode(\"apt install: missing package name\\n\"));\n    return 1;\n  }\n  const pkg = index.find((p) => p.name === name);\n  if (!pkg) {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: package not found\\n\"));\n    return 1;\n  }\n  let data;\n  try {\n    data = await readFile(syscall, pkg.path);\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: package file missing\\n\"));\n    return 1;\n  }\n  if (pkg.sha256) {\n    const digest = await sha256Hex(data);\n    if (digest !== pkg.sha256) {\n      await syscall(\"write\", STDERR_FD, encode(\"apt: checksum failed\\n\"));\n      return 1;\n    }\n  }\n  const files = parseTar(data);\n  let theme = false;\n  for (const f of files) {\n    if (f.name === \"theme.css\" || f.name === \"wallpaper.jpg\")\n      theme = true;\n  }\n  const installed = [];\n  if (theme) {\n    try {\n      await syscall(\"mkdir\", \"/opt\", 493);\n    } catch {\n    }\n    try {\n      await syscall(\"mkdir\", \"/opt/themes\", 493);\n    } catch {\n    }\n    try {\n      await syscall(\"mkdir\", `/opt/themes/${name}`, 493);\n    } catch {\n    }\n    for (const f of files) {\n      const dest = `/opt/themes/${name}/` + f.name;\n      const fd = await syscall(\"open\", dest, \"w\");\n      await syscall(\"write\", fd, f.data);\n      await syscall(\"close\", fd);\n      installed.push(dest);\n    }\n  } else {\n    try {\n      await syscall(\"mkdir\", \"/usr\", 493);\n    } catch {\n    }\n    try {\n      await syscall(\"mkdir\", \"/usr/bin\", 493);\n    } catch {\n    }\n    for (const f of files) {\n      const dest = \"/usr/bin/\" + f.name;\n      const fd = await syscall(\"open\", dest, \"w\");\n      await syscall(\"write\", fd, f.data);\n      await syscall(\"close\", fd);\n      installed.push(dest);\n    }\n  }\n  try {\n    await syscall(\"mkdir\", \"/var\", 493);\n  } catch {\n  }\n  try {\n    await syscall(\"mkdir\", \"/var/pkg\", 493);\n  } catch {\n  }\n  const manFd = await syscall(\"open\", `/var/pkg/${name}.json`, \"w\");\n  await syscall(\"write\", manFd, encode(JSON.stringify({ files: installed }) + \"\\n\"));\n  await syscall(\"close\", manFd);\n  await syscall(\"write\", STDOUT_FD, encode(\"installed \" + name + \"\\n\"));\n  return 0;\n}";
export const BASH_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  let cwd = \"/\";\n  const resolve = (p) => {\n    if (!p)\n      return cwd;\n    if (p.startsWith(\"/\"))\n      p = p;\n    else\n      p = (cwd.endsWith(\"/\") ? cwd : cwd + \"/\") + p;\n    const parts = p.split(\"/\").filter((s) => s && s !== \".\");\n    const stack = [];\n    for (const part of parts) {\n      if (part === \"..\")\n        stack.pop();\n      else\n        stack.push(part);\n    }\n    return \"/\" + stack.join(\"/\");\n  };\n  let history = [];\n  async function loadHistory() {\n    try {\n      const fd = await syscall(\"open\", HIST_PATH, \"r\");\n      let data = \"\";\n      while (true) {\n        const chunk = await syscall(\"read\", fd, 1024);\n        if (chunk.length === 0)\n          break;\n        data += decode(chunk);\n      }\n      await syscall(\"close\", fd);\n      history = data.split(\"\\n\").filter((l) => l);\n    } catch {\n    }\n  }\n  async function appendHistory(cmd) {\n    try {\n      const fd = await syscall(\"open\", HIST_PATH, \"a\");\n      await syscall(\"write\", fd, encode(cmd + \"\\n\"));\n      await syscall(\"close\", fd);\n    } catch {\n    }\n  }\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  async function complete(prefix) {\n    try {\n      const ents = await syscall(\"readdir\", \"/bin\");\n      return ents.map((e) => e.path.split(\"/\").pop()).filter((n) => n.startsWith(prefix));\n    } catch {\n      return [];\n    }\n  }\n  async function readLine(fd) {\n    let line = \"\";\n    let histIndex = history.length;\n    const redraw = async () => {\n      await syscall(\"write\", STDOUT_FD, encode(\"\\r\\x1B[K$ \" + line));\n    };\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1);\n      if (chunk.length === 0)\n        continue;\n      const ch = decode(chunk);\n      if (ch === \"\\n\") {\n        await syscall(\"write\", STDOUT_FD, encode(\"\\n\"));\n        break;\n      }\n      if (ch === \"\\x7F\") {\n        if (line.length > 0) {\n          line = line.slice(0, -1);\n          await redraw();\n        }\n        continue;\n      }\n      if (ch === \"\t\") {\n        const words = line.split(/\\s+/);\n        const prefix = words[words.length - 1];\n        const matches = await complete(prefix);\n        if (matches.length === 1) {\n          words[words.length - 1] = matches[0];\n          line = words.join(\" \");\n          await redraw();\n        } else if (matches.length > 1) {\n          await syscall(\"write\", STDOUT_FD, encode(\"\\n\" + matches.join(\" \") + \"\\n\"));\n          await redraw();\n        }\n        continue;\n      }\n      if (ch === \"\\x1B\") {\n        const seq = decode(await syscall(\"read\", fd, 2));\n        if (seq === \"[A\") {\n          if (histIndex > 0)\n            histIndex--;\n          line = history[histIndex] ?? \"\";\n          await redraw();\n        } else if (seq === \"[B\") {\n          if (histIndex < history.length)\n            histIndex++;\n          line = histIndex < history.length ? history[histIndex] : \"\";\n          await redraw();\n        }\n        continue;\n      }\n      line += ch;\n    }\n    return line;\n  }\n  async function waitPid(pid) {\n    while (true) {\n      const list = await syscall(\"ps\");\n      const proc = list.find((p) => p.pid === pid);\n      if (!proc || proc.exited)\n        break;\n      await new Promise((r) => setTimeout(r, 50));\n    }\n  }\n  const ttyName = argv[0] || \"tty0\";\n  let tty;\n  try {\n    tty = await syscall(\"open\", \"/dev/\" + ttyName, \"r\");\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"bash: unable to open tty\\n\"));\n    return 1;\n  }\n  await loadHistory();\n  const initLimits = await syscall(\"set_quota\");\n  let quotaMs = initLimits.quotaMs;\n  let quotaMem = initLimits.quotaMem;\n  let nextJob = 1;\n  const jobs = [];\n  while (true) {\n    await syscall(\"write\", STDOUT_FD, encode(\"$ \"));\n    const line = (await readLine(tty)).trim();\n    if (!line)\n      continue;\n    history.push(line);\n    await appendHistory(line);\n    if (line === \"exit\")\n      break;\n    if (line === \"pwd\") {\n      await syscall(\"write\", STDOUT_FD, encode(cwd + \"\\n\"));\n      continue;\n    }\n    if (line.startsWith(\"cd \")) {\n      const target = line.slice(3).trim() || \"/\";\n      const full = resolve(target);\n      const rc = await syscall(\"chdir\", target);\n      if (rc === 0) {\n        cwd = full;\n      } else {\n        await syscall(\"write\", STDERR_FD, encode(\"bash: cd: \" + target + \": No such file or directory\\n\"));\n      }\n      continue;\n    }\n    if (line === \"jobs\") {\n      let list;\n      try {\n        list = await syscall(\"jobs\");\n      } catch {\n        list = jobs;\n      }\n      for (const j of list) {\n        await syscall(\n          \"write\",\n          STDOUT_FD,\n          encode(\"[\" + j.id + \"] \" + (j.status || j.state) + \" \" + j.command + \"\\n\")\n        );\n      }\n      continue;\n    }\n    if (line.startsWith(\"fg \")) {\n      const id = parseInt(line.slice(3).trim(), 10);\n      const job = jobs.find((j) => j.id === id);\n      if (job) {\n        for (const pid of job.pids) {\n          await waitPid(pid);\n        }\n        job.state = \"Done\";\n      }\n      continue;\n    }\n    if (line.startsWith(\"bg \")) {\n      const id = parseInt(line.slice(3).trim(), 10);\n      const job = jobs.find((j) => j.id === id);\n      if (job)\n        job.state = \"Running\";\n      continue;\n    }\n    if (line.startsWith(\"ulimit\")) {\n      const parts = line.split(/\\s+/).slice(1);\n      if (parts.length === 0) {\n        await syscall(\"write\", STDOUT_FD, encode(\"cpu \" + quotaMs + \" mem \" + quotaMem + \"\\n\"));\n      } else {\n        for (let i = 0; i < parts.length; i++) {\n          if (parts[i] === \"-t\" && parts[i + 1]) {\n            quotaMs = parseInt(parts[i + 1], 10);\n            i++;\n          } else if (parts[i] === \"-m\" && parts[i + 1]) {\n            quotaMem = parseInt(parts[i + 1], 10);\n            i++;\n          }\n        }\n        await syscall(\"set_quota\", quotaMs, quotaMem);\n      }\n      continue;\n    }\n    if (line.startsWith(\"kill\")) {\n      const args2 = line.slice(4).trim().split(/\\s+/).filter((a) => a);\n      for (const arg of args2) {\n        if (arg.startsWith(\"%\")) {\n          const id = parseInt(arg.slice(1), 10);\n          let list;\n          try {\n            list = await syscall(\"jobs\");\n          } catch {\n            list = jobs;\n          }\n          const job = list.find((j) => j.id === id);\n          if (job) {\n            for (const pid of job.pids) {\n              await syscall(\"kill\", pid);\n            }\n          }\n        } else {\n          const pid = parseInt(arg, 10);\n          if (!isNaN(pid)) {\n            await syscall(\"kill\", pid);\n          }\n        }\n      }\n      continue;\n    }\n    const bg = line.endsWith(\"&\");\n    const cmd = bg ? line.slice(0, -1).trim() : line;\n    const [name, ...args] = cmd.split(\" \");\n    try {\n      const code = await readFile(\"/bin/\" + name);\n      let m;\n      try {\n        m = JSON.parse(await readFile(\"/bin/\" + name + \".manifest.json\"));\n      } catch {\n      }\n      const pid = await syscall(\"spawn\", code, { argv: args, syscalls: m ? m.syscalls : void 0, tty: ttyName, quotaMs, quotaMem, cwd });\n      const job = { id: nextJob++, pids: [pid], command: cmd, state: \"Running\" };\n      jobs.push(job);\n      if (!bg) {\n        await waitPid(pid);\n        job.state = \"Done\";\n      }\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"bash: \" + name + \": command not found\\n\"));\n    }\n  }\n  await syscall(\"close\", tty);\n  return 0;\n}";
export const BROWSER_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"browser: missing url\\n\"));\n    return 1;\n  }\n  const url = argv[0];\n  const html = \"<h1>Requested URL: \" + url + \"</h1>\";\n  await syscall(\"draw\", new TextEncoder().encode(html), { title: \"browser\" });\n  return 0;\n}";
export const CAT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (str) => new TextEncoder().encode(str);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"cat: missing operand\\n\"));\n    return 1;\n  }\n  const path = argv[0];\n  const READ_CHUNK_SIZE = 1024;\n  let fd = -1;\n  try {\n    fd = await syscall(\"open\", path, \"r\");\n    while (true) {\n      const data = await syscall(\"read\", fd, READ_CHUNK_SIZE);\n      if (data.length === 0) {\n        break;\n      }\n      await syscall(\"write\", STDOUT_FD, data);\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"cat: \" + path + \": \" + msg + \"\\n\"));\n    return 1;\n  } finally {\n    if (fd >= 0) {\n      await syscall(\"close\", fd);\n    }\n  }\n  return 0;\n}";
export const DESKTOP_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  const progs = [\"browser\", ...argv];\n  for (const cmd of progs) {\n    const [name, ...args] = cmd.split(\" \");\n    try {\n      const code = await readFile(\"/bin/\" + name);\n      let m;\n      try {\n        m = JSON.parse(await readFile(\"/bin/\" + name + \".manifest.json\"));\n      } catch {\n      }\n      await syscall(\"spawn\", code, { argv: args, syscalls: m ? m.syscalls : void 0 });\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"desktop: failed to launch \" + name + \"\\n\"));\n    }\n  }\n  let theme = \"default\";\n  try {\n    theme = (await readFile(\"/etc/theme\")).trim() || \"default\";\n  } catch {\n  }\n  const cssLink = `<link rel=\"stylesheet\" href=\"/opt/themes/${theme}/theme.css\">`;\n  const wallpaperPath = `/opt/themes/${theme}/wallpaper.jpg`;\n  const wallpaper = `<style>body{margin:0;background:#004 url('${wallpaperPath}') center/cover no-repeat;}</style>${cssLink}`;\n  await syscall(\"draw\", new TextEncoder().encode(wallpaper), {\n    title: \"Desktop\",\n    width: 800,\n    height: 600,\n    x: 0,\n    y: 0\n  });\n  const panelHtml = `\n        <style>\n            body{margin:0;background:#222;color:#fff;font-family:sans-serif;font-size:14px;display:flex;align-items:center;justify-content:flex-end;padding:4px;}\n        </style>\n        <div id=\"clock\"></div>\n        <script>\n        onMessage((msg)=>{\n            if(msg.type==='tick'){\n                document.getElementById('clock').textContent=new Date(msg.time).toLocaleTimeString();\n            }\n        });\n        </script>\n    `;\n  const panelId = await syscall(\"draw\", new TextEncoder().encode(panelHtml), {\n    title: \"Panel\",\n    width: 800,\n    height: 30,\n    x: 0,\n    y: 0\n  });\n  setInterval(() => {\n    eventBus.emit(\"desktop.windowPost\", { id: panelId, data: { type: \"tick\", time: Date.now() } });\n  }, 1e3);\n  return 0;\n}";
export const ECHO_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (str) => new TextEncoder().encode(str);\n  let outputFd = STDOUT_FD;\n  let path = null;\n  let message = \"\";\n  const redirectionIndex = argv.indexOf(\">\");\n  if (redirectionIndex > -1) {\n    path = argv[redirectionIndex + 1];\n    if (!path) {\n      await syscall(\"write\", STDERR_FD, encode(\"echo: missing redirection file\\n\"));\n      return 1;\n    }\n    message = argv.slice(0, redirectionIndex).join(\" \") + \"\\n\";\n  } else {\n    message = argv.join(\" \") + \"\\n\";\n  }\n  const bytes = encode(message);\n  try {\n    if (path) {\n      outputFd = await syscall(\"open\", path, \"w\");\n    }\n    if (bytes.length > 0) {\n      await syscall(\"write\", outputFd, bytes);\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"echo: \" + msg + \"\\n\"));\n    return 1;\n  } finally {\n    if (outputFd !== STDOUT_FD) {\n      await syscall(\"close\", outputFd);\n    }\n  }\n  return 0;\n}";
export const INIT_SOURCE = "async function main(syscall) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  try {\n    const code = await readFile(\"/bin/login\");\n    let m;\n    try {\n      m = JSON.parse(await readFile(\"/bin/login.manifest.json\"));\n    } catch {\n    }\n    await syscall(\"spawn\", code, { syscalls: m ? m.syscalls : void 0 });\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"init: failed to launch login\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const KILL_SOURCE = "async function main(syscall, argv) {\n  const pids = [];\n  for (const arg of argv) {\n    if (arg.startsWith(\"%\")) {\n      const id = parseInt(arg.slice(1), 10);\n      try {\n        const list = await syscall(\"jobs\");\n        const job = list.find((j) => j.id === id);\n        if (job)\n          pids.push(...job.pids);\n      } catch {\n      }\n    } else {\n      const pid = parseInt(arg, 10);\n      if (!isNaN(pid))\n        pids.push(pid);\n    }\n  }\n  for (const pid of pids) {\n    try {\n      await syscall(\"kill\", pid);\n    } catch {\n    }\n  }\n  return 0;\n}";
export const LOGIN_SOURCE = "async function main(syscall) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  async function readLine(fd) {\n    let line = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1);\n      if (chunk.length === 0)\n        break;\n      const ch = decode(chunk);\n      if (ch === \"\\n\")\n        break;\n      line += ch;\n    }\n    return line;\n  }\n  const ttyName = \"tty0\";\n  let tty;\n  try {\n    tty = await syscall(\"open\", \"/dev/\" + ttyName, \"r\");\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"login: /dev/\" + ttyName + \" not found\\n\"));\n    return 1;\n  }\n  await syscall(\"write\", STDOUT_FD, encode(\"login: \"));\n  await readLine(tty);\n  await syscall(\"write\", STDOUT_FD, encode(\"password: \"));\n  await readLine(tty);\n  await syscall(\"close\", tty);\n  try {\n    const code = await readFile(\"/bin/bash\");\n    let m;\n    try {\n      m = JSON.parse(await readFile(\"/bin/bash.manifest.json\"));\n    } catch {\n    }\n    await syscall(\"spawn\", code, { syscalls: m ? m.syscalls : void 0, tty: ttyName });\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"login: failed to launch shell\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const LS_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const path = argv[0] || \"/\";\n  try {\n    const entries = await syscall(\"readdir\", path);\n    const names = entries.map((e) => e.path.split(\"/\").pop()).join(\"\\n\") + \"\\n\";\n    await syscall(\"write\", STDOUT_FD, encode(names));\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"ls: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const MKDIR_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"mkdir: missing operand\\n\"));\n    return 1;\n  }\n  try {\n    await syscall(\"mkdir\", argv[0], 493);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"mkdir: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const MV_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, encode(\"mv: missing operand\\n\"));\n    return 1;\n  }\n  try {\n    await syscall(\"rename\", argv[0], argv[1]);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"mv: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const NANO_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"nano: missing file\\n\"));\n    return 1;\n  }\n  const path = argv[0];\n  let content = \"\";\n  try {\n    const fd = await syscall(\"open\", path, \"r\");\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      content += new TextDecoder().decode(chunk);\n    }\n    await syscall(\"close\", fd);\n  } catch (e) {\n  }\n  const escaped = content.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n  const html = \"<pre>\" + escaped + \"</pre>\";\n  await syscall(\"draw\", new TextEncoder().encode(html), { title: \"nano - \" + path });\n  return 0;\n}";
export const PING_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const ip = argv[0] || \"127.0.0.1\";\n  const port = argv[1] ? parseInt(argv[1], 10) : 7;\n  try {\n    const sock = await syscall(\"connect\", ip, port);\n    const start = Date.now();\n    const resp = await syscall(\"tcp_send\", sock, encode(\"ping\"));\n    const end = Date.now();\n    if (resp) {\n      await syscall(\"write\", STDOUT_FD, encode(\"pong \" + (end - start) + \"ms\\n\"));\n    } else {\n      await syscall(\"write\", STDERR_FD, encode(\"no response\\n\"));\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"ping: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const PS_SOURCE = "async function main(syscall) {\n  const STDOUT_FD = 1;\n  const encode = (s) => new TextEncoder().encode(s);\n  const procs = await syscall(\"ps\");\n  const totalCpu = procs.reduce((n, p) => n + (p.cpuMs || 0), 0);\n  const totalMem = procs.reduce((n, p) => n + (p.memBytes || 0), 0);\n  let lines = \"PID %CPU %MEM TTY COMMAND\\n\";\n  for (const p of procs) {\n    const cpu = totalCpu ? ((p.cpuMs || 0) / totalCpu * 100).toFixed(1) : \"0.0\";\n    const mem = totalMem ? ((p.memBytes || 0) / totalMem * 100).toFixed(1) : \"0.0\";\n    const tty = p.tty ? p.tty : \"?\";\n    const cmd = p.argv ? p.argv.join(\" \") : \"\";\n    lines += p.pid + \" \" + cpu + \" \" + mem + \" \" + tty + \" \" + cmd + \"\\n\";\n  }\n  await syscall(\"write\", STDOUT_FD, encode(lines));\n  return 0;\n}";
export const REBOOT_SOURCE = "async function main(syscall) {\n  await syscall(\"reboot\");\n  return 0;\n}";
export const RM_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"rm: missing operand\\n\"));\n    return 1;\n  }\n  try {\n    await syscall(\"unlink\", argv[0]);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"rm: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const SLEEP_SOURCE = "async function main(_syscall, argv) {\n  const ms = parseInt(argv[0] || \"1\", 10) * 1e3;\n  await new Promise((r) => setTimeout(r, ms));\n  return 0;\n}";
export const SNAPSHOT_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, encode(\"usage: snapshot <save|load> <name>\\n\"));\n    return 1;\n  }\n  const action = argv[0];\n  const name = argv[1];\n  if (action === \"save\") {\n    const snap = await syscall(\"snapshot\");\n    await syscall(\"save_snapshot_named\", name, snap);\n    return 0;\n  }\n  if (action === \"load\") {\n    await syscall(\"load_snapshot_named\", name);\n    await syscall(\"reboot\");\n    return 0;\n  }\n  await syscall(\"write\", STDERR_FD, encode(\"snapshot: unknown action\\n\"));\n  return 1;\n}";
export const STARTX_SOURCE = "async function main(syscall) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  try {\n    const code = await readFile(\"/bin/desktop\");\n    let manifest;\n    try {\n      manifest = JSON.parse(\n        await readFile(\"/bin/desktop.manifest.json\")\n      );\n    } catch {\n    }\n    await syscall(\"spawn\", code, {\n      argv: [],\n      syscalls: manifest ? manifest.syscalls : void 0\n    });\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"startx: failed to launch desktop\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const THEMES_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv[0] !== \"select\" || !argv[1]) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: themes select <name>\\n\"));\n    return 1;\n  }\n  const name = argv[1];\n  try {\n    await syscall(\"mkdir\", \"/etc\", 493);\n  } catch {\n  }\n  const fd = await syscall(\"open\", \"/etc/theme\", \"w\");\n  await syscall(\"write\", fd, enc(name));\n  await syscall(\"close\", fd);\n  await syscall(\"write\", STDOUT_FD, enc(`theme set to ${name}\n`));\n  return 0;\n}";
export const ULIMIT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    const res = await syscall(\"set_quota\");\n    await syscall(\"write\", STDOUT_FD, encode(\"cpu \" + res.quotaMs + \" mem \" + res.quotaMem + \"\\n\"));\n    return 0;\n  }\n  let ms;\n  let mem;\n  for (let i = 0; i < argv.length; i++) {\n    if (argv[i] === \"-t\") {\n      ms = parseInt(argv[i + 1] || \"0\", 10);\n      i++;\n    } else if (argv[i] === \"-m\") {\n      mem = parseInt(argv[i + 1] || \"0\", 10);\n      i++;\n    }\n  }\n  await syscall(\"set_quota\", ms, mem);\n  return 0;\n}";
export const XRANDR_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDOUT_FD, enc(\"usage: xrandr --add-monitor WxH | --remove-monitor ID\\n\"));\n    return 0;\n  }\n  try {\n    if (argv[0] === \"--add-monitor\") {\n      const [w, h] = argv[1].split(\"x\").map((n) => parseInt(n, 10));\n      if (!w || !h)\n        throw new Error(\"bad resolution\");\n      const id = await syscall(\"add_monitor\", w, h);\n      await syscall(\"write\", STDOUT_FD, enc(`monitor ${id} added\n`));\n    } else if (argv[0] === \"--remove-monitor\") {\n      const id = parseInt(argv[1], 10);\n      if (isNaN(id))\n        throw new Error(\"bad id\");\n      const res = await syscall(\"remove_monitor\", id);\n      if (res === 0) {\n        await syscall(\"write\", STDOUT_FD, enc(`monitor ${id} removed\n`));\n      } else {\n        await syscall(\"write\", STDERR_FD, enc(\"xrandr: failed\\n\"));\n        return 1;\n      }\n    } else {\n      await syscall(\"write\", STDERR_FD, enc(\"xrandr: unknown option\\n\"));\n      return 1;\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"xrandr: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";

export const APT_MANIFEST = JSON.stringify({
    "name": "apt",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "mkdir"
    ]
});
export const BASH_MANIFEST = JSON.stringify({
    "name": "bash",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn",
        "ps",
        "jobs",
        "kill",
        "set_quota"
    ]
});
export const BROWSER_MANIFEST = JSON.stringify({
    "name": "browser",
    "syscalls": [
        "draw"
    ]
});
export const CAT_MANIFEST = JSON.stringify({
    "name": "cat",
    "syscalls": [
        "open",
        "read",
        "write",
        "close"
    ]
});
export const DESKTOP_MANIFEST = JSON.stringify({
    "name": "desktop",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn",
        "draw"
    ]
});
export const ECHO_MANIFEST = JSON.stringify({
    "name": "echo",
    "syscalls": [
        "open",
        "write",
        "close"
    ]
});
export const INIT_MANIFEST = JSON.stringify({
    "name": "init",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn"
    ]
});
export const KILL_MANIFEST = JSON.stringify({
    "name": "kill",
    "syscalls": [
        "kill",
        "jobs"
    ]
});
export const LOGIN_MANIFEST = JSON.stringify({
    "name": "login",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn"
    ]
});
export const LS_MANIFEST = JSON.stringify({
    "name": "ls",
    "syscalls": [
        "readdir",
        "write"
    ]
});
export const MKDIR_MANIFEST = JSON.stringify({
    "name": "mkdir",
    "syscalls": [
        "mkdir",
        "write"
    ]
});
export const MV_MANIFEST = JSON.stringify({
    "name": "mv",
    "syscalls": [
        "rename",
        "write"
    ]
});
export const NANO_MANIFEST = JSON.stringify({
    "name": "nano",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "draw"
    ]
});
export const PING_MANIFEST = JSON.stringify({
    "name": "ping",
    "syscalls": [
        "connect",
        "tcp_send",
        "write"
    ]
});
export const PS_MANIFEST = JSON.stringify({
    "name": "ps",
    "syscalls": [
        "ps",
        "write"
    ]
});
export const REBOOT_MANIFEST = JSON.stringify({
    "name": "reboot",
    "syscalls": [
        "reboot"
    ]
});
export const RM_MANIFEST = JSON.stringify({
    "name": "rm",
    "syscalls": [
        "unlink",
        "write"
    ]
});
export const SLEEP_MANIFEST = JSON.stringify({
    "name": "sleep",
    "syscalls": []
});
export const SNAPSHOT_MANIFEST = JSON.stringify({
    "name": "snapshot",
    "syscalls": [
        "snapshot",
        "save_snapshot_named",
        "load_snapshot_named",
        "reboot",
        "write"
    ]
});
export const STARTX_MANIFEST = JSON.stringify({
    "name": "startx",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn"
    ]
});
export const THEMES_MANIFEST = JSON.stringify({
    "name": "themes",
    "syscalls": [
        "open",
        "write",
        "close",
        "mkdir"
    ]
});
export const ULIMIT_MANIFEST = JSON.stringify({
    "name": "ulimit",
    "syscalls": [
        "set_quota",
        "write"
    ]
});

export const BUNDLED_APPS = new Map<string, string>([
    ["nano", NANO_SOURCE],
    ["browser", BROWSER_SOURCE],
    ["ping", PING_SOURCE],
    ["desktop", DESKTOP_SOURCE],
    ["startx", STARTX_SOURCE],
    ["ls", LS_SOURCE],
    ["mkdir", MKDIR_SOURCE],
    ["rm", RM_SOURCE],
    ["mv", MV_SOURCE],
    ["ps", PS_SOURCE],
    ["kill", KILL_SOURCE],
    ["init", INIT_SOURCE],
    ["login", LOGIN_SOURCE],
    ["bash", BASH_SOURCE],
    ["snapshot", SNAPSHOT_SOURCE],
    ["ulimit", ULIMIT_SOURCE],
    ["apt", APT_SOURCE],
    ["themes", THEMES_SOURCE],
]);

