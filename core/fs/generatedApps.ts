// This file is generated by tools/build-apps.ts
// Do not edit manually.

export const APT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const action = argv[0];\n  if (!action || action !== \"search\" && action !== \"install\" && action !== \"remove\") {\n    await syscall(\"write\", STDERR_FD, encode(\"usage: apt <search|install|remove> <pkg>\\n\"));\n    return 1;\n  }\n  let indexRaw;\n  try {\n    indexRaw = await readText(syscall, \"/etc/apt/index.json\");\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: index not found\\n\"));\n    return 1;\n  }\n  let index;\n  try {\n    index = JSON.parse(indexRaw);\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: bad index\\n\"));\n    return 1;\n  }\n  if (action === \"search\") {\n    const term = argv[1] || \"\";\n    for (const p of index) {\n      if (p.name.includes(term)) {\n        await syscall(\"write\", STDOUT_FD, encode(p.name + \"\\n\"));\n      }\n    }\n    return 0;\n  }\n  if (action === \"remove\") {\n    const name2 = argv[1];\n    if (!name2) {\n      await syscall(\"write\", STDERR_FD, encode(\"apt remove: missing package name\\n\"));\n      return 1;\n    }\n    let manRaw;\n    try {\n      manRaw = await readText(syscall, `/var/pkg/${name2}.json`);\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"apt: package not installed\\n\"));\n      return 1;\n    }\n    let manifest;\n    try {\n      manifest = JSON.parse(manRaw);\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"apt: bad manifest\\n\"));\n      return 1;\n    }\n    let owners = [];\n    try {\n      owners = await syscall(\"window_owners\");\n    } catch {\n    }\n    const toKill = [];\n    for (const [, pid] of owners) {\n      try {\n        const fd = await syscall(\"open\", `/proc/${pid}/status`, \"r\");\n        const data2 = [];\n        while (true) {\n          const chunk = await syscall(\"read\", fd, 256);\n          if (chunk.length === 0)\n            break;\n          data2.push(chunk);\n        }\n        await syscall(\"close\", fd);\n        let len2 = 0;\n        for (const c of data2)\n          len2 += c.length;\n        const buf = new Uint8Array(len2);\n        let off2 = 0;\n        for (const c of data2) {\n          buf.set(c, off2);\n          off2 += c.length;\n        }\n        const text = new TextDecoder().decode(buf);\n        if (text.includes(`cmd:\t${name2}`))\n          toKill.push(pid);\n      } catch {\n      }\n    }\n    for (const pid of toKill) {\n      await syscall(\"kill\", pid, 9);\n      try {\n        const fds = await syscall(\"readdir\", `/proc/${pid}/fd`);\n        if (fds.length > 0) {\n          await syscall(\"write\", STDERR_FD, encode(`apt: warning process ${pid} still has open fds\n`));\n        }\n      } catch {\n      }\n    }\n    let services = [];\n    try {\n      services = await syscall(\"list_services\");\n    } catch {\n    }\n    for (const [svc] of services) {\n      if (svc.startsWith(name2 + \":\") || svc === name2) {\n        try {\n          await syscall(\"stop_service\", svc);\n        } catch {\n        }\n      }\n    }\n    for (const f of manifest.files) {\n      try {\n        await syscall(\"unlink\", f);\n      } catch {\n      }\n    }\n    try {\n      await syscall(\"unlink\", `/var/pkg/${name2}.json`);\n    } catch {\n    }\n    await syscall(\"write\", STDOUT_FD, encode(\"removed \" + name2 + \"\\n\"));\n    return 0;\n  }\n  const name = argv[1];\n  if (!name) {\n    await syscall(\"write\", STDERR_FD, encode(\"apt install: missing package name\\n\"));\n    return 1;\n  }\n  const pkg = index.find((p) => p.name === name);\n  if (!pkg) {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: package not found\\n\"));\n    return 1;\n  }\n  let data;\n  try {\n    data = await readFile(syscall, pkg.path);\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"apt: package file missing\\n\"));\n    return 1;\n  }\n  if (pkg.sha256) {\n    const digest = await sha256Hex(data);\n    if (digest !== pkg.sha256) {\n      await syscall(\"write\", STDERR_FD, encode(\"apt: checksum failed\\n\"));\n      return 1;\n    }\n  }\n  const files = parseTar(data);\n  let theme = false;\n  for (const f of files) {\n    if (f.name === \"theme.css\" || f.name === \"wallpaper.jpg\")\n      theme = true;\n  }\n  const installed = [];\n  if (theme) {\n    try {\n      await syscall(\"mkdir\", \"/opt\", 493);\n    } catch {\n    }\n    try {\n      await syscall(\"mkdir\", \"/opt/themes\", 493);\n    } catch {\n    }\n    try {\n      await syscall(\"mkdir\", `/opt/themes/${name}`, 493);\n    } catch {\n    }\n    for (const f of files) {\n      const dest = `/opt/themes/${name}/` + f.name;\n      const fd = await syscall(\"open\", dest, \"w\");\n      await syscall(\"write\", fd, f.data);\n      await syscall(\"close\", fd);\n      installed.push(dest);\n    }\n  } else {\n    try {\n      await syscall(\"mkdir\", \"/usr\", 493);\n    } catch {\n    }\n    try {\n      await syscall(\"mkdir\", \"/usr/bin\", 493);\n    } catch {\n    }\n    for (const f of files) {\n      const dest = \"/usr/bin/\" + f.name;\n      const fd = await syscall(\"open\", dest, \"w\");\n      await syscall(\"write\", fd, f.data);\n      await syscall(\"close\", fd);\n      installed.push(dest);\n    }\n  }\n  try {\n    await syscall(\"mkdir\", \"/var\", 493);\n  } catch {\n  }\n  try {\n    await syscall(\"mkdir\", \"/var/pkg\", 493);\n  } catch {\n  }\n  const manFd = await syscall(\"open\", `/var/pkg/${name}.json`, \"w\");\n  await syscall(\"write\", manFd, encode(JSON.stringify({ files: installed }) + \"\\n\"));\n  await syscall(\"close\", manFd);\n  await syscall(\"write\", STDOUT_FD, encode(\"installed \" + name + \"\\n\"));\n  return 0;\n}";
export const BASH_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  let cwd = \"/\";\n  const resolve = (p) => {\n    if (!p)\n      return cwd;\n    if (p.startsWith(\"/\"))\n      p = p;\n    else\n      p = (cwd.endsWith(\"/\") ? cwd : cwd + \"/\") + p;\n    const parts = p.split(\"/\").filter((s) => s && s !== \".\");\n    const stack = [];\n    for (const part of parts) {\n      if (part === \"..\")\n        stack.pop();\n      else\n        stack.push(part);\n    }\n    return \"/\" + stack.join(\"/\");\n  };\n  let history = [];\n  async function loadHistory() {\n    try {\n      const fd = await syscall(\"open\", HIST_PATH, \"r\");\n      let data = \"\";\n      while (true) {\n        const chunk = await syscall(\"read\", fd, 1024);\n        if (chunk.length === 0)\n          break;\n        data += decode(chunk);\n      }\n      await syscall(\"close\", fd);\n      history = data.split(\"\\n\").filter((l) => l);\n    } catch {\n    }\n  }\n  async function appendHistory(cmd) {\n    try {\n      const fd = await syscall(\"open\", HIST_PATH, \"a\");\n      await syscall(\"write\", fd, encode(cmd + \"\\n\"));\n      await syscall(\"close\", fd);\n    } catch {\n    }\n  }\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  async function complete(prefix) {\n    try {\n      const ents = await syscall(\n        \"readdir\",\n        \"/bin\"\n      );\n      return ents.map((e) => e.path.split(\"/\").pop()).filter((n) => n.startsWith(prefix));\n    } catch {\n      return [];\n    }\n  }\n  async function readLine(fd) {\n    let line = \"\";\n    let histIndex = history.length;\n    const redraw = async () => {\n      await syscall(\"write\", tty, encode(\"\\r\\x1B[K$ \" + line));\n    };\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1);\n      if (chunk.length === 0)\n        continue;\n      const ch = decode(chunk);\n      if (ch === \"\\n\") {\n        await syscall(\"write\", tty, encode(\"\\n\"));\n        break;\n      }\n      if (ch === \"\\x7F\") {\n        if (line.length > 0) {\n          line = line.slice(0, -1);\n          await redraw();\n        }\n        continue;\n      }\n      if (ch === \"\t\") {\n        const words = line.split(/\\s+/);\n        const prefix = words[words.length - 1];\n        const matches = await complete(prefix);\n        if (matches.length === 1) {\n          words[words.length - 1] = matches[0];\n          line = words.join(\" \");\n          await redraw();\n        } else if (matches.length > 1) {\n          await syscall(\n            \"write\",\n            tty,\n            encode(\"\\n\" + matches.join(\" \") + \"\\n\")\n          );\n          await redraw();\n        }\n        continue;\n      }\n      if (ch === \"\\x1B\") {\n        const seq = decode(await syscall(\"read\", fd, 2));\n        if (seq === \"[A\") {\n          if (histIndex > 0)\n            histIndex--;\n          line = history[histIndex] ?? \"\";\n          await redraw();\n        } else if (seq === \"[B\") {\n          if (histIndex < history.length)\n            histIndex++;\n          line = histIndex < history.length ? history[histIndex] : \"\";\n          await redraw();\n        }\n        continue;\n      }\n      line += ch;\n    }\n    return line;\n  }\n  async function waitPid(pid) {\n    while (true) {\n      const list = await syscall(\"ps\");\n      const proc = list.find((p) => p.pid === pid);\n      if (!proc || proc.exited)\n        break;\n      await new Promise((r) => setTimeout(r, 50));\n    }\n  }\n  const ttyName = argv[0] || \"tty0\";\n  let tty;\n  try {\n    tty = await syscall(\"open\", \"/dev/\" + ttyName, \"rw\");\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"bash: unable to open tty\\n\"));\n    return 1;\n  }\n  await loadHistory();\n  const initLimits = await syscall(\"set_quota\");\n  let quotaMs = initLimits.quotaMs;\n  let quotaMem = initLimits.quotaMem;\n  let nextJob = 1;\n  const jobs = [];\n  while (true) {\n    await syscall(\"write\", tty, encode(\"$ \"));\n    const line = (await readLine(tty)).trim();\n    if (!line)\n      continue;\n    history.push(line);\n    await appendHistory(line);\n    if (line === \"exit\")\n      break;\n    if (line === \"pwd\") {\n      await syscall(\"write\", tty, encode(cwd + \"\\n\"));\n      continue;\n    }\n    if (line.startsWith(\"cd \")) {\n      const target = line.slice(3).trim() || \"/\";\n      const full = resolve(target);\n      const rc = await syscall(\"chdir\", target);\n      if (rc === 0) {\n        cwd = full;\n      } else {\n        await syscall(\n          \"write\",\n          STDERR_FD,\n          encode(\n            \"bash: cd: \" + target + \": No such file or directory\\n\"\n          )\n        );\n      }\n      continue;\n    }\n    if (line === \"jobs\") {\n      let list;\n      try {\n        list = await syscall(\"jobs\");\n      } catch {\n        list = jobs;\n      }\n      for (const j of list) {\n        await syscall(\n          \"write\",\n          tty,\n          encode(\n            \"[\" + j.id + \"] \" + (j.status || j.state) + \" \" + j.command + \"\\n\"\n          )\n        );\n      }\n      continue;\n    }\n    if (line.startsWith(\"fg \")) {\n      const id = parseInt(line.slice(3).trim(), 10);\n      const job = jobs.find((j) => j.id === id);\n      if (job) {\n        for (const pid of job.pids) {\n          await waitPid(pid);\n        }\n        job.state = \"Done\";\n      }\n      continue;\n    }\n    if (line.startsWith(\"bg \")) {\n      const id = parseInt(line.slice(3).trim(), 10);\n      const job = jobs.find((j) => j.id === id);\n      if (job)\n        job.state = \"Running\";\n      continue;\n    }\n    if (line.startsWith(\"ulimit\")) {\n      const parts = line.split(/\\s+/).slice(1);\n      if (parts.length === 0) {\n        await syscall(\n          \"write\",\n          tty,\n          encode(\"cpu \" + quotaMs + \" mem \" + quotaMem + \"\\n\")\n        );\n      } else {\n        for (let i = 0; i < parts.length; i++) {\n          if (parts[i] === \"-t\" && parts[i + 1]) {\n            quotaMs = parseInt(parts[i + 1], 10);\n            i++;\n          } else if (parts[i] === \"-m\" && parts[i + 1]) {\n            quotaMem = parseInt(parts[i + 1], 10);\n            i++;\n          }\n        }\n        await syscall(\"set_quota\", quotaMs, quotaMem);\n      }\n      continue;\n    }\n    if (line.startsWith(\"kill\")) {\n      const args2 = line.slice(4).trim().split(/\\s+/).filter((a) => a);\n      for (const arg of args2) {\n        if (arg.startsWith(\"%\")) {\n          const id = parseInt(arg.slice(1), 10);\n          let list;\n          try {\n            list = await syscall(\"jobs\");\n          } catch {\n            list = jobs;\n          }\n          const job = list.find((j) => j.id === id);\n          if (job) {\n            for (const pid of job.pids) {\n              await syscall(\"kill\", pid);\n            }\n          }\n        } else {\n          const pid = parseInt(arg, 10);\n          if (!isNaN(pid)) {\n            await syscall(\"kill\", pid);\n          }\n        }\n      }\n      continue;\n    }\n    const bg = line.endsWith(\"&\");\n    const cmd = bg ? line.slice(0, -1).trim() : line;\n    const [name, ...args] = cmd.split(\" \");\n    try {\n      const code = await readFile(\"/bin/\" + name);\n      let m;\n      try {\n        m = JSON.parse(\n          await readFile(\"/bin/\" + name + \".manifest.json\")\n        );\n      } catch {\n      }\n      const pid = await syscall(\"spawn\", code, {\n        argv: args,\n        syscalls: m ? m.syscalls : void 0,\n        tty: ttyName,\n        quotaMs,\n        quotaMem,\n        cwd\n      });\n      const job = {\n        id: nextJob++,\n        pids: [pid],\n        command: cmd,\n        state: \"Running\"\n      };\n      jobs.push(job);\n      if (!bg) {\n        await waitPid(pid);\n        job.state = \"Done\";\n      }\n    } catch {\n      await syscall(\n        \"write\",\n        STDERR_FD,\n        encode(\"bash: \" + name + \": command not found\\n\")\n      );\n    }\n  }\n  await syscall(\"close\", tty);\n  return 0;\n}";
export const BROWSER_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"browser: missing url\\n\"));\n    return 1;\n  }\n  const url = argv[0];\n  const html = \"<h1>Requested URL: \" + url + \"</h1>\";\n  await syscall(\"draw\", new TextEncoder().encode(html), { title: \"browser\" });\n  return 0;\n}";
export const CAT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (str) => new TextEncoder().encode(str);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"cat: missing operand\\n\"));\n    return 1;\n  }\n  const path = argv[0];\n  const READ_CHUNK_SIZE = 1024;\n  let fd = -1;\n  try {\n    fd = await syscall(\"open\", path, \"r\");\n    while (true) {\n      const data = await syscall(\"read\", fd, READ_CHUNK_SIZE);\n      if (data.length === 0) {\n        break;\n      }\n      await syscall(\"write\", STDOUT_FD, data);\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"cat: \" + path + \": \" + msg + \"\\n\"));\n    return 1;\n  } finally {\n    if (fd >= 0) {\n      await syscall(\"close\", fd);\n    }\n  }\n  return 0;\n}";
export const DESKTOP_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  const progs = [\"browser\", ...argv];\n  for (const cmd of progs) {\n    const [name, ...args] = cmd.split(\" \");\n    try {\n      const code = await readFile(\"/bin/\" + name);\n      let m;\n      try {\n        m = JSON.parse(await readFile(\"/bin/\" + name + \".manifest.json\"));\n      } catch {\n      }\n      await syscall(\"spawn\", code, { argv: args, syscalls: m ? m.syscalls : void 0 });\n    } catch {\n      await syscall(\"write\", STDERR_FD, encode(\"desktop: failed to launch \" + name + \"\\n\"));\n    }\n  }\n  let theme = \"default\";\n  try {\n    theme = (await readFile(\"/etc/theme\")).trim() || \"default\";\n  } catch {\n  }\n  const cssLink = `<link rel=\"stylesheet\" href=\"/opt/themes/${theme}/theme.css\">`;\n  const wallpaperPath = `/opt/themes/${theme}/wallpaper.jpg`;\n  const wallpaper = `<style>body{margin:0;background:#004 url('${wallpaperPath}') center/cover no-repeat;}</style>${cssLink}`;\n  await syscall(\"draw\", new TextEncoder().encode(wallpaper), {\n    title: \"Desktop\",\n    width: 800,\n    height: 600,\n    x: 0,\n    y: 0\n  });\n  const panelHtml = `\n        <style>\n            body{margin:0;background:#222;color:#fff;font-family:sans-serif;font-size:14px;display:flex;align-items:center;justify-content:flex-end;padding:4px;}\n        </style>\n        <div id=\"clock\"></div>\n        <script>\n        let raf;\n        function tick(){\n            document.getElementById('clock').textContent = new Date().toLocaleTimeString();\n            raf = requestAnimationFrame(tick);\n        }\n        document.addEventListener('visibilitychange', () => {\n            if(document.hidden){\n                cancelAnimationFrame(raf);\n            } else {\n                tick();\n            }\n        });\n        tick();\n        </script>\n    `;\n  await syscall(\"draw\", new TextEncoder().encode(panelHtml), {\n    title: \"Panel\",\n    width: 800,\n    height: 30,\n    x: 0,\n    y: 0\n  });\n  return 0;\n}";
export const DHCLIENT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv.length !== 1) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: dhclient <nic>\\n\"));\n    return 1;\n  }\n  try {\n    const res = await syscall(\"dhcp_request\", argv[0]);\n    if (typeof res === \"number\" && res < 0) {\n      await syscall(\"write\", STDERR_FD, enc(\"dhclient: failed\\n\"));\n      return 1;\n    }\n    const { ip, netmask } = res;\n    await syscall(\"write\", STDOUT_FD, enc(`${ip}/${netmask}\n`));\n    return 0;\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"dhclient: \" + msg + \"\\n\"));\n    return 1;\n  }\n}";
export const ECHO_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (str) => new TextEncoder().encode(str);\n  let outputFd = STDOUT_FD;\n  let path = null;\n  let message = \"\";\n  const redirectionIndex = argv.indexOf(\">\");\n  if (redirectionIndex > -1) {\n    path = argv[redirectionIndex + 1];\n    if (!path) {\n      await syscall(\"write\", STDERR_FD, encode(\"echo: missing redirection file\\n\"));\n      return 1;\n    }\n    message = argv.slice(0, redirectionIndex).join(\" \") + \"\\n\";\n  } else {\n    message = argv.join(\" \") + \"\\n\";\n  }\n  const bytes = encode(message);\n  try {\n    if (path) {\n      outputFd = await syscall(\"open\", path, \"w\");\n    }\n    if (bytes.length > 0) {\n      await syscall(\"write\", outputFd, bytes);\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"echo: \" + msg + \"\\n\"));\n    return 1;\n  } finally {\n    if (outputFd !== STDOUT_FD) {\n      await syscall(\"close\", outputFd);\n    }\n  }\n  return 0;\n}";
export const FTPD_SOURCE = "async function main(syscall, argv) {\n  const port = argv[0] ? parseInt(argv[0], 10) : 21;\n  const root = argv[1] ?? \"/\";\n  const enc = new TextEncoder();\n  const dec = new TextDecoder();\n  function resolve(p) {\n    const base = root.endsWith(\"/\") ? root.slice(0, -1) : root;\n    if (p.startsWith(\"/\"))\n      return base + p;\n    return base + \"/\" + p;\n  }\n  await syscall(\"listen\", port, \"tcp\", (conn) => {\n    let buffer = \"\";\n    let dataIp = null;\n    let dataPort = null;\n    conn.write(enc.encode(\"220 Helios FTP\\r\\n\"));\n    conn.onData((d) => {\n      buffer += dec.decode(d);\n      void processBuffer();\n    });\n    async function processBuffer() {\n      while (true) {\n        const idx = buffer.indexOf(\"\\r\\n\");\n        if (idx === -1)\n          break;\n        const line = buffer.slice(0, idx);\n        buffer = buffer.slice(idx + 2);\n        await handle(line.trim());\n      }\n    }\n    async function handle(line) {\n      const [cmd, ...rest] = line.split(\" \");\n      const arg = rest.join(\" \");\n      switch (cmd.toUpperCase()) {\n        case \"USER\":\n          conn.write(enc.encode(\"331 OK\\r\\n\"));\n          break;\n        case \"PASS\":\n          conn.write(enc.encode(\"230 Logged in\\r\\n\"));\n          break;\n        case \"PORT\": {\n          const nums = arg.split(\",\").map((n) => parseInt(n, 10));\n          if (nums.length === 6) {\n            dataIp = nums.slice(0, 4).join(\".\");\n            dataPort = nums[4] << 8 | nums[5];\n            conn.write(enc.encode(\"200 PORT OK\\r\\n\"));\n          } else {\n            conn.write(enc.encode(\"501 Bad PORT\\r\\n\"));\n          }\n          break;\n        }\n        case \"LIST\": {\n          if (!dataIp || dataPort === null) {\n            conn.write(enc.encode(\"425 Use PORT first\\r\\n\"));\n            break;\n          }\n          try {\n            const path = resolve(arg || \".\");\n            const list = await syscall(\"readdir\", path);\n            const names = list.map((n) => n.path.split(\"/\").pop()).join(\"\\r\\n\");\n            const dataConn = await syscall(\"connect\", dataIp, dataPort);\n            dataConn.write(enc.encode(names + \"\\r\\n\"));\n            conn.write(enc.encode(\"226 Transfer complete\\r\\n\"));\n          } catch {\n            conn.write(enc.encode(\"550 Failed to list\\r\\n\"));\n          }\n          break;\n        }\n        case \"RETR\": {\n          if (!dataIp || dataPort === null) {\n            conn.write(enc.encode(\"425 Use PORT first\\r\\n\"));\n            break;\n          }\n          try {\n            const fd = await syscall(\"open\", resolve(arg), \"r\");\n            const chunks = [];\n            while (true) {\n              const c = await syscall(\"read\", fd, 1024);\n              if (c.length === 0)\n                break;\n              chunks.push(c);\n            }\n            await syscall(\"close\", fd);\n            const total = chunks.reduce((n, c) => n + c.length, 0);\n            const buf = new Uint8Array(total);\n            let off = 0;\n            for (const c of chunks) {\n              buf.set(c, off);\n              off += c.length;\n            }\n            const dataConn = await syscall(\"connect\", dataIp, dataPort);\n            dataConn.write(buf);\n            conn.write(enc.encode(\"226 Transfer complete\\r\\n\"));\n          } catch {\n            conn.write(enc.encode(\"550 Failed to open file\\r\\n\"));\n          }\n          break;\n        }\n        case \"STOR\": {\n          if (!dataIp || dataPort === null) {\n            conn.write(enc.encode(\"425 Use PORT first\\r\\n\"));\n            break;\n          }\n          const filePath = resolve(arg);\n          await syscall(\"open\", filePath, \"w\");\n          const chunks = [];\n          const dataConn = await syscall(\"connect\", dataIp, dataPort);\n          dataConn.onData((chunk) => {\n            chunks.push(chunk);\n          });\n          await new Promise((r) => setTimeout(r, 10));\n          const total = chunks.reduce((n, c) => n + c.length, 0);\n          const buf = new Uint8Array(total);\n          let off = 0;\n          for (const c of chunks) {\n            buf.set(c, off);\n            off += c.length;\n          }\n          await syscall(\"write\", await syscall(\"open\", filePath, \"w\"), buf);\n          conn.write(enc.encode(\"226 Transfer complete\\r\\n\"));\n          break;\n        }\n        default:\n          conn.write(enc.encode(\"502 Command not implemented\\r\\n\"));\n      }\n    }\n  });\n  return 0;\n}";
export const HTTPD_SOURCE = "async function main(syscall, argv) {\n  const port = argv[0] ? parseInt(argv[0], 10) : 80;\n  const root = argv[1] ?? \"/var/www\";\n  const enc = new TextEncoder();\n  const dec = new TextDecoder();\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    const chunks = [];\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      chunks.push(chunk);\n    }\n    await syscall(\"close\", fd);\n    const total = chunks.reduce((n, c) => n + c.length, 0);\n    const buf = new Uint8Array(total);\n    let off = 0;\n    for (const c of chunks) {\n      buf.set(c, off);\n      off += c.length;\n    }\n    return buf;\n  }\n  await syscall(\"listen\", port, \"tcp\", (conn) => {\n    let buffer = \"\";\n    conn.onData((d) => {\n      buffer += dec.decode(d);\n      void processBuffer();\n    });\n    async function processBuffer() {\n      while (true) {\n        const idx = buffer.indexOf(\"\\r\\n\\r\\n\");\n        if (idx === -1)\n          break;\n        const raw = buffer.slice(0, idx);\n        buffer = buffer.slice(idx + 4);\n        const lines = raw.split(\"\\r\\n\");\n        const [method, path] = lines[0].split(\" \");\n        const clean = path.split(\"?\")[0] || \"/\";\n        const filePath = clean === \"/\" ? \"/index.html\" : clean;\n        const full = (0, import_path.normalize)((0, import_path.join)(root, \".\" + filePath));\n        if (!full.startsWith((0, import_path.normalize)(root))) {\n          const body = \"Forbidden\";\n          const hdr = [\n            \"HTTP/1.1 403 Forbidden\",\n            `Content-Length: ${body.length}`,\n            \"Connection: close\",\n            \"\",\n            \"\"\n          ].join(\"\\r\\n\");\n          conn.write(enc.encode(hdr));\n          if (method === \"GET\")\n            conn.write(enc.encode(body));\n          continue;\n        }\n        try {\n          const data = await readFile(full);\n          const hdr = [\n            \"HTTP/1.1 200 OK\",\n            `Content-Length: ${data.length}`,\n            \"Connection: keep-alive\",\n            \"\",\n            \"\"\n          ].join(\"\\r\\n\");\n          conn.write(enc.encode(hdr));\n          if (method === \"GET\")\n            conn.write(data);\n        } catch {\n          const body = \"Not Found\";\n          const hdr = [\n            \"HTTP/1.1 404 Not Found\",\n            `Content-Length: ${body.length}`,\n            \"Connection: close\",\n            \"\",\n            \"\"\n          ].join(\"\\r\\n\");\n          conn.write(enc.encode(hdr));\n          if (method === \"GET\")\n            conn.write(enc.encode(body));\n        }\n      }\n    }\n  });\n  return 0;\n}";
export const IFCONFIG_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  try {\n    if (argv.length === 0) {\n      const list = await syscall(\"list_nics\");\n      let out = \"\";\n      for (const n of list) {\n        const ip = n.ip ?? \"0.0.0.0\";\n        const mask = n.netmask ?? \"0\";\n        out += `${n.id} ${ip}/${mask} ${n.status}\n`;\n      }\n      await syscall(\"write\", STDOUT_FD, enc(out));\n      return 0;\n    }\n    const id = argv[0];\n    if (argv.length === 2) {\n      if (argv[1] === \"up\") {\n        await syscall(\"nic_up\", id);\n        return 0;\n      }\n      if (argv[1] === \"down\") {\n        await syscall(\"nic_down\", id);\n        return 0;\n      }\n      if (argv[1].includes(\"/\")) {\n        const [ip, mask] = argv[1].split(\"/\");\n        await syscall(\"nic_config\", id, ip, mask);\n        return 0;\n      }\n    }\n    await syscall(\"write\", STDERR_FD, enc(\"ifconfig: bad usage\\n\"));\n    return 1;\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"ifconfig: \" + msg + \"\\n\"));\n    return 1;\n  }\n}";
export const INIT_SOURCE = "async function main(syscall) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  try {\n    const code = await readFile(\"/bin/login\");\n    let m;\n    try {\n      m = JSON.parse(await readFile(\"/bin/login.manifest.json\"));\n    } catch {\n    }\n    await syscall(\"spawn\", code, { syscalls: m ? m.syscalls : void 0 });\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"init: failed to launch login\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const IWCONFIG_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv.length < 3) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: iwconfig <nic> <ssid> <passphrase>\\n\"));\n    return 1;\n  }\n  const [nic, ssid, pass] = argv;\n  try {\n    const res = await syscall(\"wifi_join\", nic, ssid, pass);\n    if (typeof res === \"number\" && res < 0) {\n      await syscall(\"write\", STDERR_FD, enc(\"iwconfig: failed\\n\"));\n      return 1;\n    }\n    return 0;\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"iwconfig: \" + msg + \"\\n\"));\n    return 1;\n  }\n}";
export const IWLIST_SOURCE = "async function main(syscall, _argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  try {\n    const list = await syscall(\"wifi_scan\");\n    await syscall(\"write\", STDOUT_FD, enc(list.join(\"\\n\") + \"\\n\"));\n    return 0;\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"iwlist: \" + msg + \"\\n\"));\n    return 1;\n  }\n}";
export const KEYMAP_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  const dec = (b) => new TextDecoder().decode(b);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: keymap <key> <code>\\n\"));\n    return 1;\n  }\n  const key = argv[0];\n  const code = parseInt(argv[1], 10);\n  if (isNaN(code)) {\n    await syscall(\"write\", STDERR_FD, enc(\"keymap: invalid code\\n\"));\n    return 1;\n  }\n  async function readConfig() {\n    try {\n      const fd = await syscall(\"open\", \"/etc/input.json\", \"r\");\n      let text = \"\";\n      while (true) {\n        const chunk = await syscall(\"read\", fd, 1024);\n        if (chunk.length === 0)\n          break;\n        text += dec(chunk);\n      }\n      await syscall(\"close\", fd);\n      return JSON.parse(text);\n    } catch {\n      return {};\n    }\n  }\n  const cfg = await readConfig();\n  if (!cfg.keymap || typeof cfg.keymap !== \"object\")\n    cfg.keymap = {};\n  cfg.keymap[key] = code;\n  try {\n    await syscall(\"mkdir\", \"/etc\", 493);\n  } catch {\n  }\n  const fdw = await syscall(\"open\", \"/etc/input.json\", \"w\");\n  await syscall(\"write\", fdw, enc(JSON.stringify(cfg) + \"\\n\"));\n  await syscall(\"close\", fdw);\n  await syscall(\"write\", STDOUT_FD, enc(`mapped ${key}\n`));\n  return 0;\n}";
export const KILL_SOURCE = "async function main(syscall, argv) {\n  const pids = [];\n  for (const arg of argv) {\n    if (arg.startsWith(\"%\")) {\n      const id = parseInt(arg.slice(1), 10);\n      try {\n        const list = await syscall(\"jobs\");\n        const job = list.find((j) => j.id === id);\n        if (job)\n          pids.push(...job.pids);\n      } catch {\n      }\n    } else {\n      const pid = parseInt(arg, 10);\n      if (!isNaN(pid))\n        pids.push(pid);\n    }\n  }\n  for (const pid of pids) {\n    try {\n      await syscall(\"kill\", pid);\n    } catch {\n    }\n  }\n  return 0;\n}";
export const LOGIN_SOURCE = "async function main(syscall) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  async function readLine(fd) {\n    let line = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1);\n      if (chunk.length === 0)\n        break;\n      const ch = decode(chunk);\n      if (ch === \"\\n\")\n        break;\n      line += ch;\n    }\n    return line;\n  }\n  const ttyName = \"tty0\";\n  let tty;\n  try {\n    tty = await syscall(\"open\", \"/dev/\" + ttyName, \"rw\");\n  } catch {\n    await syscall(\n      \"write\",\n      STDERR_FD,\n      encode(\"login: /dev/\" + ttyName + \" not found\\n\")\n    );\n    return 1;\n  }\n  await syscall(\"write\", tty, encode(\"login: \"));\n  await readLine(tty);\n  await syscall(\"write\", tty, encode(\"password: \"));\n  await readLine(tty);\n  await syscall(\"close\", tty);\n  try {\n    const code = await readFile(\"/bin/bash\");\n    let m;\n    try {\n      m = JSON.parse(await readFile(\"/bin/bash.manifest.json\"));\n    } catch {\n    }\n    await syscall(\"spawn\", code, {\n      syscalls: m ? m.syscalls : void 0,\n      tty: ttyName\n    });\n  } catch {\n    await syscall(\n      \"write\",\n      STDERR_FD,\n      encode(\"login: failed to launch shell\\n\")\n    );\n    return 1;\n  }\n  return 0;\n}";
export const LS_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const path = argv[0] || \"/\";\n  try {\n    const entries = await syscall(\"readdir\", path);\n    const names = entries.map((e) => e.path.split(\"/\").pop()).join(\"\\n\") + \"\\n\";\n    await syscall(\"write\", STDOUT_FD, encode(names));\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"ls: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const MAIL_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  const dec = new TextDecoder();\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: mail <ip> <user> [file]\\n\"));\n    return 1;\n  }\n  const ip = argv[0];\n  const user = argv[1];\n  const file = argv[2];\n  try {\n    const conn = await syscall(\"connect\", ip, 143);\n    let buf = \"\";\n    conn.onData((d) => {\n      buf += dec.decode(d);\n    });\n    const send = (s) => conn.write(enc(s + \"\\r\\n\"));\n    if (file) {\n      send(`RETR ${user} ${file}`);\n    } else {\n      send(`LIST ${user}`);\n    }\n    await new Promise((r) => setTimeout(r, 20));\n    await syscall(\"write\", STDOUT_FD, enc(buf));\n    return 0;\n  } catch (e) {\n    const msgStr = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"mail: \" + msgStr + \"\\n\"));\n    return 1;\n  }\n}";
export const MKDIR_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"mkdir: missing operand\\n\"));\n    return 1;\n  }\n  try {\n    await syscall(\"mkdir\", argv[0], 493);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"mkdir: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const MV_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, encode(\"mv: missing operand\\n\"));\n    return 1;\n  }\n  try {\n    await syscall(\"rename\", argv[0], argv[1]);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"mv: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const NANO_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"nano: missing file\\n\"));\n    return 1;\n  }\n  const path = argv[0];\n  let content = \"\";\n  try {\n    const fd = await syscall(\"open\", path, \"r\");\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      content += new TextDecoder().decode(chunk);\n    }\n    await syscall(\"close\", fd);\n  } catch (e) {\n  }\n  const escaped = content.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n  const html = \"<pre>\" + escaped + \"</pre>\";\n  await syscall(\"draw\", new TextEncoder().encode(html), { title: \"nano - \" + path });\n  return 0;\n}";
export const PING_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const ip = argv[0] || \"127.0.0.1\";\n  const port = argv[1] ? parseInt(argv[1], 10) : 0;\n  try {\n    const conn = await syscall(\"udp_connect\", ip, port);\n    const start = Date.now();\n    let responded = false;\n    conn.onData(() => {\n      responded = true;\n    });\n    conn.write(encode(\"ping\"));\n    const end = Date.now();\n    if (responded) {\n      await syscall(\"write\", STDOUT_FD, encode(\"pong \" + (end - start) + \"ms\\n\"));\n    } else {\n      await syscall(\"write\", STDERR_FD, encode(\"no response\\n\"));\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"ping: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const PS_SOURCE = "async function main(syscall) {\n  const STDOUT_FD = 1;\n  const encode = (s) => new TextEncoder().encode(s);\n  const procs = await syscall(\"ps\");\n  const totalCpu = procs.reduce((n, p) => n + (p.cpuMs || 0), 0);\n  const totalMem = procs.reduce((n, p) => n + (p.memBytes || 0), 0);\n  let lines = \"PID %CPU %MEM TTY COMMAND\\n\";\n  for (const p of procs) {\n    const cpu = totalCpu ? ((p.cpuMs || 0) / totalCpu * 100).toFixed(1) : \"0.0\";\n    const mem = totalMem ? ((p.memBytes || 0) / totalMem * 100).toFixed(1) : \"0.0\";\n    const tty = p.tty ? p.tty : \"?\";\n    const cmd = p.argv ? p.argv.join(\" \") : \"\";\n    lines += p.pid + \" \" + cpu + \" \" + mem + \" \" + tty + \" \" + cmd + \"\\n\";\n  }\n  await syscall(\"write\", STDOUT_FD, encode(lines));\n  return 0;\n}";
export const REBOOT_SOURCE = "async function main(syscall) {\n  await syscall(\"reboot\");\n  return 0;\n}";
export const RM_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    await syscall(\"write\", STDERR_FD, encode(\"rm: missing operand\\n\"));\n    return 1;\n  }\n  try {\n    await syscall(\"unlink\", argv[0]);\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, encode(\"rm: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const ROUTE_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: route <add|del> <cidr> [nic]\\n\"));\n    return 1;\n  }\n  const action = argv[0];\n  const cidr = argv[1];\n  if (action === \"add\") {\n    if (argv.length !== 3) {\n      await syscall(\"write\", STDERR_FD, enc(\"usage: route add <cidr> <nic>\\n\"));\n      return 1;\n    }\n    const nic = argv[2];\n    const res = await syscall(\"route_add\", cidr, nic);\n    if (typeof res === \"number\" && res < 0) {\n      await syscall(\"write\", STDERR_FD, enc(\"route: failed\\n\"));\n      return 1;\n    }\n    return 0;\n  }\n  if (action === \"del\") {\n    const res = await syscall(\"route_del\", cidr);\n    if (typeof res === \"number\" && res < 0) {\n      await syscall(\"write\", STDERR_FD, enc(\"route: failed\\n\"));\n      return 1;\n    }\n    return 0;\n  }\n  await syscall(\"write\", STDERR_FD, enc(\"route: unknown action\\n\"));\n  return 1;\n}";
export const SENDMAIL_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv.length < 3) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: sendmail <ip> <to> <msg>\\n\"));\n    return 1;\n  }\n  const ip = argv[0];\n  const to = argv[1];\n  const msg = argv.slice(2).join(\" \");\n  try {\n    const conn = await syscall(\"connect\", ip, 25);\n    const send = (s) => conn.write(enc(s + \"\\r\\n\"));\n    send(\"HELO localhost\");\n    send(\"MAIL FROM:<user@localhost>\");\n    send(`RCPT TO:<${to}>`);\n    send(\"DATA\");\n    send(msg);\n    send(\".\");\n    send(\"QUIT\");\n    await syscall(\"write\", STDOUT_FD, enc(\"sent\\n\"));\n    return 0;\n  } catch (e) {\n    const msgStr = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"sendmail: \" + msgStr + \"\\n\"));\n    return 1;\n  }\n}";
export const SERVICE_SOURCE = "async function main(syscall, argv) {\n  const STDOUT = 1;\n  const STDERR = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += new TextDecoder().decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  const action = argv[0];\n  if (!action || action === \"list\") {\n    try {\n      const list = await syscall(\"list_services\");\n      let out = \"\";\n      for (const [name, info] of list) {\n        out += `${name} ${info.proto} ${info.port}\n`;\n      }\n      await syscall(\"write\", STDOUT, enc(out));\n      return 0;\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      await syscall(\"write\", STDERR, enc(`service: ${msg}\n`));\n      return 1;\n    }\n  }\n  if (action === \"stop\") {\n    const name = argv[1];\n    if (!name) {\n      await syscall(\"write\", STDERR, enc(\"service stop: missing name\\n\"));\n      return 1;\n    }\n    try {\n      await syscall(\"stop_service\", name);\n      await syscall(\"write\", STDOUT, enc(`stopped ${name}\n`));\n      return 0;\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      await syscall(\"write\", STDERR, enc(`service: ${msg}\n`));\n      return 1;\n    }\n  }\n  if (action === \"start\") {\n    const name = argv[1];\n    if (!name) {\n      await syscall(\"write\", STDERR, enc(\"service start: missing name\\n\"));\n      return 1;\n    }\n    try {\n      const code = await readFile(`/bin/${name}`);\n      let manifest;\n      try {\n        manifest = JSON.parse(await readFile(`/bin/${name}.manifest.json`));\n      } catch {\n      }\n      await syscall(\"spawn\", code, { argv: argv.slice(2), syscalls: manifest ? manifest.syscalls : void 0 });\n      await syscall(\"write\", STDOUT, enc(`started ${name}\n`));\n      return 0;\n    } catch (e) {\n      const msg = e instanceof Error ? e.message : String(e);\n      await syscall(\"write\", STDERR, enc(`service: ${msg}\n`));\n      return 1;\n    }\n  }\n  await syscall(\"write\", STDERR, enc(\"usage: service [list|start|stop] ...\\n\"));\n  return 1;\n}";
export const SETFONT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  const dec = (b) => new TextDecoder().decode(b);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: setfont <family> <size>\\n\"));\n    return 1;\n  }\n  const family = argv[0];\n  const size = parseInt(argv[1], 10);\n  if (isNaN(size)) {\n    await syscall(\"write\", STDERR_FD, enc(\"setfont: invalid size\\n\"));\n    return 1;\n  }\n  async function readConfig() {\n    try {\n      const fd = await syscall(\"open\", \"/etc/input.json\", \"r\");\n      let text = \"\";\n      while (true) {\n        const chunk = await syscall(\"read\", fd, 1024);\n        if (chunk.length === 0)\n          break;\n        text += dec(chunk);\n      }\n      await syscall(\"close\", fd);\n      return JSON.parse(text);\n    } catch {\n      return {};\n    }\n  }\n  const cfg = await readConfig();\n  cfg.fontFamily = family;\n  cfg.fontSize = size;\n  try {\n    await syscall(\"mkdir\", \"/etc\", 493);\n  } catch {\n  }\n  const fdw = await syscall(\"open\", \"/etc/input.json\", \"w\");\n  await syscall(\"write\", fdw, enc(JSON.stringify(cfg) + \"\\n\"));\n  await syscall(\"close\", fdw);\n  await syscall(\"write\", STDOUT_FD, enc(\"font updated\\n\"));\n  return 0;\n}";
export const SLEEP_SOURCE = "async function main(_syscall, argv) {\n  const ms = parseInt(argv[0] || \"1\", 10) * 1e3;\n  await new Promise((r) => setTimeout(r, ms));\n  return 0;\n}";
export const SMTP_SOURCE = "async function main(syscall, argv) {\n  const port = argv[0] ? parseInt(argv[0], 10) : 25;\n  const root = argv[1] ?? \"/var/mail\";\n  const enc = new TextEncoder();\n  const dec = new TextDecoder();\n  await syscall(\"listen\", port, \"tcp\", (conn) => {\n    let buffer = \"\";\n    let from = \"\";\n    let to = \"\";\n    let collecting = false;\n    const lines = [];\n    void conn.write(enc.encode(\"220 Helios SMTP\\r\\n\"));\n    conn.onData((d) => {\n      buffer += dec.decode(d);\n      void process();\n    });\n    async function process() {\n      while (true) {\n        const idx = buffer.indexOf(\"\\r\\n\");\n        if (idx === -1)\n          break;\n        const line = buffer.slice(0, idx);\n        buffer = buffer.slice(idx + 2);\n        await handle(line.trim());\n      }\n    }\n    async function handle(line) {\n      if (collecting) {\n        if (line === \".\") {\n          const dir = (0, import_path.normalize)((0, import_path.join)(root, to));\n          try {\n            await syscall(\"mkdir\", \"/var\", 493);\n          } catch {\n          }\n          try {\n            await syscall(\"mkdir\", root, 493);\n          } catch {\n          }\n          try {\n            await syscall(\"mkdir\", dir, 493);\n          } catch {\n          }\n          const file = (0, import_path.join)(dir, `${Date.now()}.txt`);\n          await syscall(\"open\", file, \"w\");\n          const content = `From: ${from}\\r\nTo: ${to}\\r\n` + lines.join(\"\\r\\n\") + \"\\r\\n\";\n          await syscall(\"write\", await syscall(\"open\", file, \"w\"), enc.encode(content));\n          lines.length = 0;\n          collecting = false;\n          void conn.write(enc.encode(\"250 OK\\r\\n\"));\n        } else {\n          lines.push(line);\n        }\n        return;\n      }\n      const [cmd, ...rest] = line.split(\" \");\n      const arg = rest.join(\" \");\n      switch (cmd.toUpperCase()) {\n        case \"HELO\":\n        case \"EHLO\":\n          void conn.write(enc.encode(\"250 Hello\\r\\n\"));\n          break;\n        case \"MAIL\":\n          from = arg.split(\":\")[1] || \"\";\n          void conn.write(enc.encode(\"250 OK\\r\\n\"));\n          break;\n        case \"RCPT\":\n          to = (arg.split(\":\")[1] || \"\").replace(/[<>]/g, \"\");\n          void conn.write(enc.encode(\"250 OK\\r\\n\"));\n          break;\n        case \"DATA\":\n          collecting = true;\n          void conn.write(enc.encode(\"354 End data with <CR><LF>.<CR><LF>\\r\\n\"));\n          break;\n        case \"QUIT\":\n          void conn.write(enc.encode(\"221 Bye\\r\\n\"));\n          break;\n        default:\n          void conn.write(enc.encode(\"502 Command not implemented\\r\\n\"));\n      }\n    }\n  });\n  return 0;\n}";
export const SNAPSHOT_SOURCE = "async function main(syscall, argv) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDERR_FD, encode(\"usage: snapshot <save|load> <name>\\n\"));\n    return 1;\n  }\n  const action = argv[0];\n  const name = argv[1];\n  if (action === \"save\") {\n    const snap = await syscall(\"snapshot\");\n    await syscall(\"save_snapshot_named\", name, snap);\n    return 0;\n  }\n  if (action === \"load\") {\n    await syscall(\"load_snapshot_named\", name);\n    await syscall(\"reboot\");\n    return 0;\n  }\n  await syscall(\"write\", STDERR_FD, encode(\"snapshot: unknown action\\n\"));\n  return 1;\n}";
export const SSH_SOURCE = "async function main(syscall, argv) {\n  const port = argv[0] ? parseInt(argv[0], 10) : 22;\n  const enc = new TextEncoder();\n  const dec = new TextDecoder();\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += dec.decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  async function selfPid() {\n    const list = await syscall(\"ps\");\n    const proc = list.find((p) => p.argv && p.argv[0] === \"ssh\");\n    return proc ? proc.pid : list[list.length - 1].pid;\n  }\n  await syscall(\"listen\", port, \"tcp\", (conn) => {\n    conn.write(enc.encode(\"login: \"));\n    let stage = \"user\";\n    let master = null;\n    let slave = null;\n    conn.onData(async (data) => {\n      if (stage === \"shell\") {\n        if (master !== null)\n          await syscall(\"write\", master, data);\n        return;\n      }\n      const text = dec.decode(data);\n      for (const ch of text) {\n        if (stage === \"user\") {\n          if (ch === \"\\n\") {\n            stage = \"pass\";\n            conn.write(enc.encode(\"password: \"));\n          }\n        } else if (stage === \"pass\") {\n          if (ch === \"\\n\") {\n            stage = \"shell\";\n            conn.write(enc.encode(\"\\nWelcome to Helios-OS\\n\"));\n            master = await syscall(\"open\", \"/dev/ptmx\", \"rw\");\n            const pid = await selfPid();\n            const fdPathFd = await syscall(\"open\", `/proc/${pid}/fd/${master}`, \"r\");\n            let path = \"\";\n            while (true) {\n              const c = await syscall(\"read\", fdPathFd, 64);\n              if (c.length === 0)\n                break;\n              path += dec.decode(c);\n            }\n            await syscall(\"close\", fdPathFd);\n            const idMatch = path.match(/pty(\\d+)/);\n            const id = idMatch ? parseInt(idMatch[1], 10) : 0;\n            slave = `/dev/tty${id}`;\n            const bash = await readFile(\"/bin/bash\");\n            let man;\n            try {\n              man = JSON.parse(await readFile(\"/bin/bash.manifest.json\"));\n            } catch {\n            }\n            await syscall(\"spawn\", bash, { argv: [`tty${id}`], tty: slave, syscalls: man ? man.syscalls : void 0 });\n            (async () => {\n              while (master !== null) {\n                await syscall(\"wait\", master);\n                if (master === null)\n                  break;\n                const buf = await syscall(\"read\", master, 1024);\n                if (buf.length > 0)\n                  conn.write(buf);\n              }\n            })();\n          }\n        }\n      }\n    });\n  });\n  return 0;\n}";
export const STARTX_SOURCE = "async function main(syscall) {\n  const STDERR_FD = 2;\n  const encode = (s) => new TextEncoder().encode(s);\n  const decode = (b) => new TextDecoder().decode(b);\n  async function readFile(path) {\n    const fd = await syscall(\"open\", path, \"r\");\n    let out = \"\";\n    while (true) {\n      const chunk = await syscall(\"read\", fd, 1024);\n      if (chunk.length === 0)\n        break;\n      out += decode(chunk);\n    }\n    await syscall(\"close\", fd);\n    return out;\n  }\n  try {\n    const code = await readFile(\"/bin/desktop\");\n    let manifest;\n    try {\n      manifest = JSON.parse(\n        await readFile(\"/bin/desktop.manifest.json\")\n      );\n    } catch {\n    }\n    await syscall(\"spawn\", code, {\n      argv: [],\n      syscalls: manifest ? manifest.syscalls : void 0\n    });\n  } catch {\n    await syscall(\"write\", STDERR_FD, encode(\"startx: failed to launch desktop\\n\"));\n    return 1;\n  }\n  return 0;\n}";
export const THEMES_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv[0] !== \"select\" || !argv[1]) {\n    await syscall(\"write\", STDERR_FD, enc(\"usage: themes select <name>\\n\"));\n    return 1;\n  }\n  const name = argv[1];\n  try {\n    await syscall(\"mkdir\", \"/etc\", 493);\n  } catch {\n  }\n  const fd = await syscall(\"open\", \"/etc/theme\", \"w\");\n  await syscall(\"write\", fd, enc(name));\n  await syscall(\"close\", fd);\n  await syscall(\"write\", STDOUT_FD, enc(`theme set to ${name}\n`));\n  return 0;\n}";
export const ULIMIT_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const encode = (s) => new TextEncoder().encode(s);\n  if (argv.length === 0) {\n    const res = await syscall(\"set_quota\");\n    await syscall(\n      \"write\",\n      STDOUT_FD,\n      encode(\"cpu \" + res.quotaMs + \" total \" + res.quotaMs_total + \" mem \" + res.quotaMem + \"\\n\")\n    );\n    return 0;\n  }\n  let ms;\n  let mem;\n  let total;\n  for (let i = 0; i < argv.length; i++) {\n    if (argv[i] === \"-t\") {\n      ms = parseInt(argv[i + 1] || \"0\", 10);\n      i++;\n    } else if (argv[i] === \"-m\") {\n      mem = parseInt(argv[i + 1] || \"0\", 10);\n      i++;\n    } else if (argv[i] === \"-T\") {\n      total = parseInt(argv[i + 1] || \"0\", 10);\n      i++;\n    }\n  }\n  await syscall(\"set_quota\", ms, mem, total);\n  return 0;\n}";
export const XRANDR_SOURCE = "async function main(syscall, argv) {\n  const STDOUT_FD = 1;\n  const STDERR_FD = 2;\n  const enc = (s) => new TextEncoder().encode(s);\n  if (argv.length < 2) {\n    await syscall(\"write\", STDOUT_FD, enc(\"usage: xrandr --add-monitor WxH | --remove-monitor ID\\n\"));\n    return 0;\n  }\n  try {\n    if (argv[0] === \"--add-monitor\") {\n      const [w, h] = argv[1].split(\"x\").map((n) => parseInt(n, 10));\n      if (!w || !h)\n        throw new Error(\"bad resolution\");\n      const id = await syscall(\"add_monitor\", w, h);\n      await syscall(\"write\", STDOUT_FD, enc(`monitor ${id} added\n`));\n    } else if (argv[0] === \"--remove-monitor\") {\n      const id = parseInt(argv[1], 10);\n      if (isNaN(id))\n        throw new Error(\"bad id\");\n      const res = await syscall(\"remove_monitor\", id);\n      if (res === 0) {\n        await syscall(\"write\", STDOUT_FD, enc(`monitor ${id} removed\n`));\n      } else {\n        await syscall(\"write\", STDERR_FD, enc(\"xrandr: failed\\n\"));\n        return 1;\n      }\n    } else {\n      await syscall(\"write\", STDERR_FD, enc(\"xrandr: unknown option\\n\"));\n      return 1;\n    }\n  } catch (e) {\n    const msg = e instanceof Error ? e.message : String(e);\n    await syscall(\"write\", STDERR_FD, enc(\"xrandr: \" + msg + \"\\n\"));\n    return 1;\n  }\n  return 0;\n}";

export const APT_MANIFEST = JSON.stringify({
    "name": "apt",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "mkdir"
    ]
});
export const BASH_MANIFEST = JSON.stringify({
    "name": "bash",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn",
        "ps",
        "jobs",
        "kill",
        "set_quota"
    ]
});
export const BROWSER_MANIFEST = JSON.stringify({
    "name": "browser",
    "syscalls": [
        "draw"
    ]
});
export const CAT_MANIFEST = JSON.stringify({
    "name": "cat",
    "syscalls": [
        "open",
        "read",
        "write",
        "close"
    ]
});
export const DESKTOP_MANIFEST = JSON.stringify({
    "name": "desktop",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn",
        "draw"
    ]
});
export const DHCLIENT_MANIFEST = JSON.stringify({
    "name": "dhclient",
    "syscalls": [
        "dhcp_request",
        "write"
    ]
});
export const ECHO_MANIFEST = JSON.stringify({
    "name": "echo",
    "syscalls": [
        "open",
        "write",
        "close"
    ]
});
export const FTPD_MANIFEST = JSON.stringify({
    "name": "ftpd",
    "syscalls": [
        "listen",
        "connect",
        "open",
        "read",
        "write",
        "close",
        "readdir"
    ]
});
export const HTTPD_MANIFEST = JSON.stringify({
    "name": "httpd",
    "syscalls": [
        "listen",
        "open",
        "read",
        "write",
        "close"
    ],
    "allowNode": true
});
export const IFCONFIG_MANIFEST = JSON.stringify({
    "name": "ifconfig",
    "syscalls": [
        "list_nics",
        "nic_up",
        "nic_down",
        "nic_config",
        "write"
    ]
});
export const INIT_MANIFEST = JSON.stringify({
    "name": "init",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn"
    ]
});
export const IWCONFIG_MANIFEST = JSON.stringify({
    "name": "iwconfig",
    "syscalls": [
        "wifi_join",
        "write"
    ]
});
export const IWLIST_MANIFEST = JSON.stringify({
    "name": "iwlist",
    "syscalls": [
        "wifi_scan",
        "write"
    ]
});
export const KEYMAP_MANIFEST = JSON.stringify({
    "name": "keymap",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "mkdir"
    ]
});
export const KILL_MANIFEST = JSON.stringify({
    "name": "kill",
    "syscalls": [
        "kill",
        "jobs"
    ]
});
export const LOGIN_MANIFEST = JSON.stringify({
    "name": "login",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn"
    ]
});
export const LS_MANIFEST = JSON.stringify({
    "name": "ls",
    "syscalls": [
        "readdir",
        "write"
    ]
});
export const MAIL_MANIFEST = JSON.stringify({
    "name": "mail",
    "syscalls": [
        "connect",
        "write"
    ]
});
export const MKDIR_MANIFEST = JSON.stringify({
    "name": "mkdir",
    "syscalls": [
        "mkdir",
        "write"
    ]
});
export const MV_MANIFEST = JSON.stringify({
    "name": "mv",
    "syscalls": [
        "rename",
        "write"
    ]
});
export const NANO_MANIFEST = JSON.stringify({
    "name": "nano",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "draw"
    ]
});
export const PING_MANIFEST = JSON.stringify({
    "name": "ping",
    "syscalls": [
        "udp_connect",
        "udp_send",
        "write"
    ]
});
export const PS_MANIFEST = JSON.stringify({
    "name": "ps",
    "syscalls": [
        "ps",
        "write"
    ]
});
export const REBOOT_MANIFEST = JSON.stringify({
    "name": "reboot",
    "syscalls": [
        "reboot"
    ]
});
export const RM_MANIFEST = JSON.stringify({
    "name": "rm",
    "syscalls": [
        "unlink",
        "write"
    ]
});
export const ROUTE_MANIFEST = JSON.stringify({
    "name": "route",
    "syscalls": [
        "route_add",
        "route_del",
        "write"
    ]
});
export const SENDMAIL_MANIFEST = JSON.stringify({
    "name": "sendmail",
    "syscalls": [
        "connect",
        "write"
    ]
});
export const SERVICE_MANIFEST = JSON.stringify({
    "name": "service",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn",
        "list_services",
        "stop_service"
    ]
});
export const SETFONT_MANIFEST = JSON.stringify({
    "name": "setfont",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "mkdir"
    ]
});
export const SLEEP_MANIFEST = JSON.stringify({
    "name": "sleep",
    "syscalls": []
});
export const SMTP_MANIFEST = JSON.stringify({
    "name": "smtp",
    "syscalls": [
        "listen",
        "open",
        "write",
        "mkdir",
        "close"
    ],
    "allowNode": true
});
export const SNAPSHOT_MANIFEST = JSON.stringify({
    "name": "snapshot",
    "syscalls": [
        "snapshot",
        "save_snapshot_named",
        "load_snapshot_named",
        "reboot",
        "write"
    ]
});
export const SSH_MANIFEST = JSON.stringify({
    "name": "ssh",
    "syscalls": [
        "listen",
        "open",
        "read",
        "write",
        "close",
        "spawn",
        "ps"
    ]
});
export const STARTX_MANIFEST = JSON.stringify({
    "name": "startx",
    "syscalls": [
        "open",
        "read",
        "write",
        "close",
        "spawn"
    ]
});
export const THEMES_MANIFEST = JSON.stringify({
    "name": "themes",
    "syscalls": [
        "open",
        "write",
        "close",
        "mkdir"
    ]
});
export const ULIMIT_MANIFEST = JSON.stringify({
    "name": "ulimit",
    "syscalls": [
        "set_quota",
        "write"
    ]
});

export const BUNDLED_APPS = new Map<string, string>([
    ["nano", NANO_SOURCE],
    ["browser", BROWSER_SOURCE],
    ["ping", PING_SOURCE],
    ["iwlist", IWLIST_SOURCE],
    ["iwconfig", IWCONFIG_SOURCE],
    ["dhclient", DHCLIENT_SOURCE],
    ["route", ROUTE_SOURCE],
    ["ifconfig", IFCONFIG_SOURCE],
    ["sendmail", SENDMAIL_SOURCE],
    ["mail", MAIL_SOURCE],
    ["desktop", DESKTOP_SOURCE],
    ["startx", STARTX_SOURCE],
    ["ls", LS_SOURCE],
    ["mkdir", MKDIR_SOURCE],
    ["rm", RM_SOURCE],
    ["mv", MV_SOURCE],
    ["ps", PS_SOURCE],
    ["kill", KILL_SOURCE],
    ["init", INIT_SOURCE],
    ["login", LOGIN_SOURCE],
    ["bash", BASH_SOURCE],
    ["snapshot", SNAPSHOT_SOURCE],
    ["ulimit", ULIMIT_SOURCE],
    ["apt", APT_SOURCE],
    ["themes", THEMES_SOURCE],
    ["setfont", SETFONT_SOURCE],
    ["keymap", KEYMAP_SOURCE],
    ["service", SERVICE_SOURCE],
    ["ssh", SSH_SOURCE],
    ["httpd", HTTPD_SOURCE],
    ["ftpd", FTPD_SOURCE],
    ["smtp", SMTP_SOURCE],
]);

